#include <iostream>

using namespace std;

int Sejong01_ReviewC_Pointer() {
	// 예제 1
	int num = 3;
	int* pnum = &num;

	*pnum = *pnum / 2 + 4;

	if (*pnum == 5) {
		++*pnum;
	}
	cout << "예제 1 : " << *pnum << "\n";

	// 예제 2
	int arr[5] = { 2, 3, 5, 7, -1 };
	int* pArr = arr;

	cout << "예제 2 : ";
	for (pArr = arr; pArr < &arr[5]; pArr++) {
		cout << *pArr << ", ";
	}
	cout << "\n";

	// 예제 3
	int a = 1, b = 2, c = 3;
	int* pi[3];
	pi[0] = &a;
	pi[1] = &b;
	pi[2] = &c;

	*pi[0] = -1;

	cout << "예제 3 : ";
	// &pi[i] : pi배열의 주소값
	// pi[i] : pi배열에 있는 a, b, c의 주소값
	// *pi[i] : pi배열에 있는 a, b, c의 값
	for (int i = 0; i < 3; i++) {
		cout << &pi[i] << "(" << *pi[i] << ")" << ", ";
	}
	cout << "\n";

	return 0;
}

/*
1. 포인터 개요
	1) 메모리
	  - 1byte(8bit) 단위 물리 주소
	  - 일반적으로 4bytes, 16진수로 표현
	
	2) 변수와 메모리의 관계
	  - 주소연산자(&) : 변수에 할당된 메모리
		int a = 0;
		printf("%d : %p", a, &a); // %p : 주소 16진수로 출력
		
		result. 0 - a의 주소

	3) 변수의 의미
	  - 할당된 공간
	  - 저장된 값s

	4) 포인터(자료형)
	  - 주소를 나타내는 특수 자료형
	  - 주소는 기본적으로 양의 정수로 표현, int와 구별되어 처리

=====

2. 포인터 선언과 사용
	1) 변수 명 앞에 *(참조연산자) 추가
		ex. char *pch;
			int *pnum;
		=> pch와 pnum은 똑같이 주소를 저장하지만 대상의 자료형이 다르기 때문에 다른 자료형 취급
	
	2) 초기화
	  - int num, *pnum = &num; // num이 먼저 선언되어야 함

	3) 포인터 대입(연결)
	  - 포인터(변수)에 주소를 대입하여 특정 변수와 연결시키는 것을 가리킨다 라고 표현, 그림에서 -> 표시
		char ch = 'A', *pch;
		int num = 3, *pnum;

		pch = &ch; // pch에 변수 ch의 주소 대입
		pnum = &num; // pnum에 변수 num의 주소 대입

	4) 포인터 참조
	  - 포인터가 가리키는 변수에 접근하는 것
	  - 참조 연산자 : * (간접연산자, 포인터 연산자)
	  - *pch : 포인터 pch가 가리키는 변수
	  - 간접 접근 : *pch = 'B'
	  - 직접 접근 : ch = 'B'

	5) 주소연산자와 참조연산자 정리
	  - 주소연산자(&) : 해당 변수의 주소값
	  - 참조연산자(*) : 포인터가 가리키는 변수값
	  - 변수 이름 : 변수 영역 또는 변수에 저장된 값
	  => ㅁ(일반변수), o(포인터변수), -> : 연결

	6) 사용 주의사항
	  - 선언 후 연결 없이 바로 사용하면 런타임 오류 발생 (int *pnum;)
		- Null : 주소값 0, 아무것도 가리키지 않음
	  - &(주소연산자)는 포인터를 포함한 모든 변수에 사용가능, *(참조연산자)는 포인터 변수에서만 사용 가능
	  - 포인터의 자료형과 연결됨 변수의 자료는 일치 (num == *pnum)

	7) 포인터의 크기
	  - 포인터 종류에 관계 없이 주소 크기(4byte)

=====

3. 배열과 포인터
	1) 배열
	  - 배열 이름은 배열의 0번 원소 시작 주소
	  - 배열 이름은 주소, 참조 연산자와 함께 사용 가능 (a[0] == *ar)
	
	2) 배열과 포인터 관계 정리
	  - 배열과 포인터는 동일한 형태로 사용 가능
		int ar[5], *p = ar;
		ar[0] == p[0] == *(ar + 0) == *(p + 0);
	  - 주소가 주어졌을 때 주소에 저장된 원소값을 참조하는 형태 2가지
		ar[3], p[3] // 배열의 참조 연산자[] 사용
		*(ar + 3), *(p + 3) // 포인터의 참조 연산자 * 사용
	
	3) 배열 이름과 포인터 변수의 차이
	  - int num;
	    - 변수 num에 저장된 값(정수, ex.9) 변경 가능, 할당된 주소(ex.0x9A) 변경 불가
	  - int *p;
		- 변수 p에 저장된 값(주소, ex.0x9A) 변경 가능, 할당된 주소 변경 불가
	  - int arr[5];
	    - 배열 arr에 저장된 값 변경 가능, 할당된 주소 변경 불가
		- 배열 이름은 포인터 상수로 변경하지 못한다
		- 대입문의 왼쪽에서 사용될 때 (I-value)차이 발생

	4) 배열과 포인터 주의사함
	  - 포인터를 배열의 중간 원소에 연결시키는 것 가능 (int *p = &arr[2])
	  - 포인터의 참조 연산자 사용 시 괄호에 유의
	    arr[5] = {1, 3, 5, 7, 9}
	    *(arr + 2) -> arr[2] -> 5 
		*(arr) + 2 -> *(arr) + 2 -> arr[0] + 2 -> 3
	  - 포인터 변수의 증감량은 가리키는 배열의 원소 크기가 아니라 포인터 자신의 자료형에 의해 결정

=====

4. 포인터 연산
	1) 주소에 정수를 더하거나 빼기
	2) 비교연산자 사용
	  - 주소 비교를 이용하여 배열 훑어보기
	  - 예제 2

=====

5. 포인터 인자와 주소 반환
	1) 배열과 포인터 관계 정리
	  - 배열의 index 사용 방법과 동일
	2) 함수 인자 비교
	  - 값에 의한 호출(call-by-value) : 정수 값이나 문자 등을 인자로 함수를 호출하는 것
	  - 주소에 의한 호출(cal-by-reference) : 주소를 인자로 함수를 호출하는 것
	  => 두 호출 방식의 함수의 호출 과정(인자 전달 및 제어흐름)은 완전히 동일

=====

6.포인터 배열
	1) 포인터 배열
	  - 포인터 변수들의 묶음
	  - 포인터 선언 + 배열 선언
	  - 예제 3

=====

7. 다중 포인터
	1) 이중 포인터
	  - int 포인터 변수의 주소를 저장하는 변수
	  - int** : int 포인터 변수의 주소를 저장하는 변수의 자료형

*/